Started with creating a function to handled objectfile construction

Make a function to handle Record creation 
-> Created tRecord List: LinkedList for tRecords
-> Created mRecord List: LinkedList for mRecords
-> Created struct hRecord
-> Created struct eRecord

Created Pass2 taking in table from p2(Pass1)

Passes hRecord, rtable, mtable, and eRecord into GenerateObjectFile:
Only present in Pass2
Prints header 
Prints thru tRecord List
Prints thru mRecord List
Prints end

Created Instruction.c:
Handles opcode interpretation
Takes "string" opcode 
Returns hex representation

Created SymbolAddress() in IsInSymbolTable.calculated

Created a way to read operands with # and @

Created a way to read opcodes witn +

Moved Pass1 to a seperate file:
This was to make it easier for me to read 
as well as add the --pass1only option

Researched more on how opcodes are generated:
it is not a 1:1 translation per se
I assumed how records were handled with two things:
1. hex opcode value
2. current address

Did some personal research
1. It is made in binary and converted to hex.
2. Format 3/4 drops the last 2 binary digits
3. Depending on the n,i,x,b,p,e bits will dictate how the displacement address will be calculated or if it would use direct addressing
4. M Records are still not fully understood 
